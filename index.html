<!DOCTYPE html>

<html>
<head>
  <title>DOM Utilities</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h1>DOM Utilities</h1>
<p>This is a collection of common utility methods for the DOM. While similar in nature to libraries like jQuery, this library aims to provide methods for unique and odd features.</p>
            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h2>Cursor</h2>
<p>This represents a point in a DOM tree that is “in-between” elements or text characters. Just like a real text cursor, this is meant to mark a specific location for adding or manipulating text in DOM tree.</p><p>Cursor extends the JavaScript Array class, so all the methods available to arrays are also available to Cursor. Unlike normal arrays, however, cursors have a fixed size of two.</p><p>As an example, here is a cursor which marks the beginning of the document body:</p><pre><code class="lang-javascript"><span class="hljs-keyword">var</span> cursor = <span class="hljs-keyword">new</span> domUtils.Cursor(<span class="hljs-built_in">document</span>.body, <span class="hljs-literal">false</span>);
</code></pre>
<h4>Arguments</h4>
<ul>
<li><strong>node</strong> <em>Node</em> - The DOM node specifying the position in the DOM tree.</li>
<li><strong>index</strong> <em>integer</em> - This represents the exact character index of the DOM position. If the DOM node is a text node, this is the index of the <code>nodeValue</code> string. Otherwise, this acts like a boolean, stating which side of the element the cursor should appear on. In this case <code>true</code> means “after” and <code>false</code> means “before”.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Cursor =
exports.Cursor = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node, index)</span> </span>{
    <span class="hljs-keyword">if</span> (!isNode(node)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Expecting node for cursor."</span>);
    <span class="hljs-keyword">this</span>.node = node;
    <span class="hljs-keyword">this</span>.index = index;
    <span class="hljs-keyword">this</span>.length = <span class="hljs-number">2</span>;
}

<span class="hljs-comment">// extends Array, as best as JS allows</span>
Cursor.prototype.__proto__ = <span class="hljs-built_in">Array</span>.prototype;</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h3>Instance Properties</h3>
<ul>
<li><strong>cursor.node</strong> <em>Node</em> - A DOM node.</li>
<li><strong>cursor.index</strong> <em>integer</em> - The exact character index of the DOM position.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-built_in">Object</span>.defineProperty(Cursor.prototype, <span class="hljs-string">"node"</span>, {
    get: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>]; },
    set: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(n)</span> </span>{
        <span class="hljs-keyword">if</span> (!isNode(n)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Expecting a node."</span>);
        <span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>] = n;
    }
});

<span class="hljs-built_in">Object</span>.defineProperty(Cursor.prototype, <span class="hljs-string">"index"</span>, {
    get: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[<span class="hljs-number">1</span>]; },
    set: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(n)</span> </span>{
        <span class="hljs-keyword">if</span> (n == <span class="hljs-literal">null</span>) n = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> n === <span class="hljs-string">"boolean"</span>) n = n ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> n !== <span class="hljs-string">"number"</span> || <span class="hljs-built_in">isNaN</span>(n) || n &lt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Expecting a non-negative integer for the index."</span>);
        }
        <span class="hljs-keyword">this</span>[<span class="hljs-number">1</span>] = n;
    }
});</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <h3>Cursor#clone()</h3>
<p>Creates a duplicate cursor with same values.</p>
            </div>
            
            <div class="content"><div class='highlight'><pre>Cursor.prototype.clone = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Cursor(<span class="hljs-keyword">this</span>.node, <span class="hljs-keyword">this</span>.index);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h3>Cursor#isAfter()</h3>
<p>Determines if another cursor can be considered after this cursor in the DOM.</p><h4>Arguments</h4>
<ul>
<li><strong>cursor</strong> <em>Cursor</em> - A cursor to determine the position of relative to this one.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>Cursor.prototype.isAfter = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(cursor)</span> </span>{
    cursor = Cursor.toCursor(cursor);
    
    <span class="hljs-comment">// the same node changes the game</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.node === cursor.node) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.node.nodeType === Node.TEXT_NODE ?
            <span class="hljs-keyword">this</span>.index &gt; cursor.index :
            <span class="hljs-keyword">this</span>.index ? cursor.index ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
    }

    <span class="hljs-comment">// where to start looking depends on cursor location</span>
    <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>.index ? <span class="hljs-keyword">this</span>.node : getPreviousExtendedSibling(<span class="hljs-keyword">this</span>.node);
    
    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (contains(node, cursor.node)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        node = getPreviousExtendedSibling(node);
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h3>Cursor#isBefore()</h3>
<p>Determines if another cursor can be considered before this cursor in the DOM.</p><h4>Arguments</h4>
<ul>
<li><strong>cursor</strong> <em>Cursor</em> - A cursor to determine the position of relative to this one.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>Cursor.prototype.isBefore = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(cursor)</span> </span>{
    cursor = Cursor.toCursor(cursor);
    
    <span class="hljs-comment">// the same node changes the game</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.node === cursor.node) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.node.nodeType === Node.TEXT_NODE ?
            <span class="hljs-keyword">this</span>.index &lt; cursor.index :
            <span class="hljs-keyword">this</span>.index ? <span class="hljs-literal">false</span> : cursor.index ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
    }
    
    <span class="hljs-comment">// where to start looking depends on cursor location</span>
    <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>.index ? getNextExtendedSibling(<span class="hljs-keyword">this</span>.node) : <span class="hljs-keyword">this</span>.node;
    
    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (contains(node, cursor.node)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        node = getNextExtendedSibling(node);
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <h3>Cursor#move()</h3>
<p>Moves the cursor from it’s current position by a character offset. This method returns <code>this</code> for method chaining.</p><h4>Arguments</h4>
<ul>
<li><strong>offset</strong> <em>integer</em> - The number of text characters to move the cursor by. A negative value moves the cursor in reverse, a positive value will move it forward.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>Cursor.prototype.move = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(offset)</span> </span>{
    <span class="hljs-keyword">var</span> count, reverse, node, index, curnode, len;

    count = <span class="hljs-number">0</span>;
    reverse = offset &lt; <span class="hljs-number">0</span>;
    offset = <span class="hljs-built_in">Math</span>.abs(offset);
    node = <span class="hljs-keyword">this</span>.node;
    index = <span class="hljs-keyword">this</span>.index;
    
    <span class="hljs-comment">// determine the true starting node</span>
    <span class="hljs-keyword">if</span> (node.nodeType === Node.TEXT_NODE) {
        <span class="hljs-comment">// we move the count to maintain index</span>
        count = reverse ? index : <span class="hljs-built_in">Math</span>.max(getTextContent(node).length - index, <span class="hljs-number">0</span>);
    
        <span class="hljs-comment">// if the count exceeds our max, we've hit the exact position</span>
        <span class="hljs-keyword">if</span> (count &gt; offset) {
            <span class="hljs-keyword">this</span>.index = reverse ? index - offset : index + offset;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        }

        <span class="hljs-comment">// text node lookups never include the current node</span>
        curnode = reverse ? getPreviousExtendedSibling(node) : getNextExtendedSibling(node);
    }
    
    <span class="hljs-comment">// non-text nodes are all handled the same</span>
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// check whether to include the node in the count</span>
        curnode = index ? <span class="hljs-comment">// true means "after", false means "before"</span>
        reverse ? node : getNextExtendedSibling(node) :
        reverse ? getPreviousExtendedSibling(node) : node;
    }
    
    <span class="hljs-comment">// walk the tree until we find the spot we want</span>
    <span class="hljs-keyword">while</span> (curnode != <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// only count element and text nodes</span>
        <span class="hljs-keyword">if</span> (~[ Node.ELEMENT_NODE, Node.TEXT_NODE ].indexOf(curnode.nodeType)) {
            len = getTextContent(curnode).length;
        
            <span class="hljs-comment">// check if the length exceeds</span>
            <span class="hljs-keyword">if</span> (count + len &gt; offset) {
                <span class="hljs-comment">// we "dive" into elements and continue the search</span>
                <span class="hljs-keyword">if</span> (curnode.nodeType === Node.ELEMENT_NODE) {
                    curnode = reverse ? curnode.lastChild : curnode.firstChild;
                    <span class="hljs-keyword">continue</span>;
                }
                
                <span class="hljs-comment">// text nodes are the exact position</span>
                index = offset - count;
                <span class="hljs-keyword">this</span>.node = curnode;
                <span class="hljs-keyword">this</span>.index = reverse ? len - index : index;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            }
            
            <span class="hljs-comment">// otherwise bump the count</span>
            <span class="hljs-keyword">else</span> {
                count += len;
            }
        }
        
        <span class="hljs-comment">// always get the next node</span>
        curnode = reverse ? getPreviousExtendedSibling(curnode) : getNextExtendedSibling(curnode);
    }
    
    <span class="hljs-comment">// if we got here, it means the offset was out of bounds</span>
    <span class="hljs-comment">// instead we move the cursor to the very end or beginning of the root</span>
    <span class="hljs-keyword">this</span>.node = getRootNode(node);
    <span class="hljs-keyword">this</span>.index = !reverse;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <h3>Cursor.isCursor()</h3>
<p>Determines if a value is DOM cursor.</p><h4>Arguments</h4>
<ul>
<li><strong>value</strong> <em>mixed</em> - A value to check as an isntance of Cursor.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>Cursor.isCursor = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(v)</span> </span>{
    <span class="hljs-keyword">return</span> v <span class="hljs-keyword">instanceof</span> Cursor;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <h3>Cursor.toCursor()</h3>
<p>Converts a value into a cursor. This is mainly so a type check isn’t necessary when accepting both cursors and arrays.</p><h4>Arguments</h4>
<ul>
<li><strong>node</strong> <em>Cursor | Node | Array</em> - A value to convert to a cursor.</li>
<li><strong>index</strong> <em>integer; optional</em> - The index of the cursor.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>Cursor.toCursor = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node, index)</span> </span>{
    <span class="hljs-keyword">if</span> (Cursor.isCursor(node)) <span class="hljs-keyword">return</span> node;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(node)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Cursor(node[<span class="hljs-number">0</span>], node[<span class="hljs-number">1</span>]);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Cursor(node, index);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <h2>isNode()</h2>
<p>Determines if a value is a DOM node.</p><h4>Arguments</h4>
<ul>
<li><strong>value</strong> <em>mixed</em> - A value to test as a DOM node.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> isNode =
exports.isNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node)</span> </span>{
    <span class="hljs-keyword">return</span> node <span class="hljs-keyword">instanceof</span> Node;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <h2>matchesSelector()</h2>
<p>A cross browser compatible solution to testing a DOM element against a CSS selector.</p><h4>Arguments</h4>
<ul>
<li><strong>node</strong> <em>Node</em> - A DOM node to test.</li>
<li><strong>selector</strong> <em>string</em> - A CSS selector.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> matchesSelector = <span class="hljs-keyword">typeof</span> Element !== <span class="hljs-string">"undefined"</span> ?
    Element.prototype.matches ||
    Element.prototype.webkitMatchesSelector ||
    Element.prototype.mozMatchesSelector ||
    Element.prototype.msMatchesSelector :
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; };

exports.matchesSelector = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node, selector)</span> </span>{
    <span class="hljs-keyword">return</span> matchesSelector.call(node, selector)
}</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <h2>matches()</h2>
<p>Similar to <code>matchesSelector()</code>, this method will test a DOM node against CSS selectors, other DOM nodes and functions.</p><h4>Arguments</h4>
<ul>
<li><strong>node</strong> <em>Node</em> - A DOM node to test.</li>
<li><strong>selector</strong> <em>string | function | Node</em> - A CSS selector, a function (called with one argument, the node) or a DOM node.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> matches =
exports.matches = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node, selector)</span> </span>{
    <span class="hljs-keyword">if</span> (isNode(selector)) <span class="hljs-keyword">return</span> node === selector;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> selector === <span class="hljs-string">"function"</span>) <span class="hljs-keyword">return</span> !!selector.call(node);
    <span class="hljs-keyword">return</span> matchesSelector.call(node, selector);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <h2>getFirstLeafNode()</h2>
<p>Returns the first descendant node without children or <code>null</code> if doesn’t exist.</p><h4>Arguments</h4>
<ul>
<li><strong>node</strong> <em>Node</em> - A DOM node to find the first leaf of.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> getFirstLeafNode =
exports.getFirstLeafNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node)</span> </span>{
    <span class="hljs-keyword">while</span> (node.hasChildNodes()) node = node.firstChild;
    <span class="hljs-keyword">return</span> node;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <h2>getLastLeafNode()</h2>
<p>Returns the last descendant node without children or <code>null</code> if doesn’t exist.</p><h4>Arguments</h4>
<ul>
<li><strong>node</strong> <em>Node</em> - A DOM node to find the last leaf of.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> getLastLeafNode =
exports.getLastLeafNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node)</span> </span>{
    <span class="hljs-keyword">while</span> (node.hasChildNodes()) node = node.lastChild;
    <span class="hljs-keyword">return</span> node;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <h2>getNextExtendedSibling()</h2>
<p>Returns the next sibling of this node, a direct ancestor node’s next sibling, or <code>null</code>.</p><h4>Arguments</h4>
<ul>
<li><strong>node</strong> <em>Node</em> - A node to get the next extended sibling of.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> getNextExtendedSibling =
exports.getNextExtendedSibling = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node)</span> </span>{
    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (node.nextSibling != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> node.nextSibling;
        node = node.parentNode;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <h2>getPreviousExtendedSibling()</h2>
<p>Returns the previous sibling of this node, a direct ancestor node’s previous sibling, or <code>null</code>.</p><h4>Arguments</h4>
<ul>
<li><strong>node</strong> <em>Node</em> - A node to get the previous extended sibling of.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> getPreviousExtendedSibling =
exports.getPreviousExtendedSibling = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node)</span> </span>{
    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (node.previousSibling != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> node.previousSibling;
        node = node.parentNode;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <h2>getNextNode()</h2>
<p>Gets the next node in the DOM tree. This is either the first child node, the next sibling node, a direct ancestor node’s next sibling, or <code>null</code>.</p><h4>Arguments</h4>
<ul>
<li><strong>node</strong> <em>Node</em> - A node to get the next node of.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> getNextNode =
exports.getNextNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node)</span> </span>{
    <span class="hljs-keyword">return</span> node.hasChildNodes() ? node.firstChild : getNextExtendedSibling(node);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <h2>getPreviousNode()</h2>
<p>Gets the previous node in the DOM tree. This will return the previous extended sibling’s last, deepest leaf node or <code>null</code> if doesn’t exist. This returns the exact opposite result of <code>getNextNode</code> (ie <code>getNextNode(getPreviousNode(node)) === node</code>).</p><h4>Arguments</h4>
<ul>
<li><strong>node</strong> <em>Node</em> - A node to get the previous node of.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> getPreviousNode =
exports.getPreviousNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node)</span> </span>{
    <span class="hljs-keyword">return</span> node.previousSibling == <span class="hljs-literal">null</span> ? node.parentNode : getLastLeafNode(node.previousSibling);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <h2>getTextContent()</h2>
<p>Gets the text content of a node and its descendants. This is the text content that is visible to a user viewing the HTML from browser. Hidden nodes, such as comments, are not included in the output.</p><h4>Arguments</h4>
<ul>
<li><strong>node</strong> <em>Node</em> - A node to get the text content of.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> getTextContent =
exports.getTextContent = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node)</span> </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(node)) <span class="hljs-keyword">return</span> node.map(getTextContent).join(<span class="hljs-string">""</span>);

    <span class="hljs-keyword">switch</span>(node.nodeType) {
        <span class="hljs-keyword">case</span> Node.DOCUMENT_NODE:
        <span class="hljs-keyword">case</span> Node.DOCUMENT_FRAGMENT_NODE:
            <span class="hljs-keyword">return</span> getTextContent(<span class="hljs-built_in">Array</span>.prototype.slice.call(node.childNodes, <span class="hljs-number">0</span>));

        <span class="hljs-keyword">case</span> Node.ELEMENT_NODE:
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> node.innerText === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> node.innerText;		<span class="hljs-comment">// webkit</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> node.textContent === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> node.textContent;	<span class="hljs-comment">// firefox</span>
            <span class="hljs-keyword">return</span> getTextContent(<span class="hljs-built_in">Array</span>.prototype.slice.call(node.childNodes, <span class="hljs-number">0</span>));<span class="hljs-comment">// other</span>
        
        <span class="hljs-keyword">case</span> Node.TEXT_NODE:
            <span class="hljs-keyword">return</span> node.nodeValue || <span class="hljs-string">""</span>;

        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
    }
}</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <h2>getRootNode()</h2>
<p>Returns the root node of a DOM tree.</p><h4>Arguments</h4>
<ul>
<li><strong>node</strong> <em>Node</em> - A node in the DOM tree you need the root of.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> getRootNode =
exports.getRootNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node)</span> </span>{
    <span class="hljs-keyword">while</span> (node.parentNode != <span class="hljs-literal">null</span>) {
        node = node.parentNode
    }
    
    <span class="hljs-keyword">return</span> node;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <h2>contains()</h2>
<p>Determines if a node is a direct ancestor of another node. This is the same syntax as jQuery’s <code>$.contains()</code>.</p><h4>Arguments</h4>
<ul>
<li><strong>parent</strong> <em>Node</em> - The ancestor node.</li>
<li><strong>node</strong> <em>Node</em> - The node which may or may not be a descendant of the parent.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> contains =
exports.contains = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(parent, node)</span> </span>{
    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (matches(node, parent)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        node = node.parentNode;
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <h2>slice()</h2>
<p>Returns a cloned copy of the all DOM content between two cursors.</p><h4>Arguments</h4>
<ul>
<li><strong>start</strong> <em>Cursor | null</em> - The cursor to start at. Pass null to slice from the beginning of the root.</li>
<li><strong>end</strong> <em>Cursor | null</em> - The cursor to end at. Pass null to slice until the end of the root.</li>
<li><strong>root</strong> <em>Node; optional</em> - Any common ancestor between the starting node and the ending node. If not passed, it will use the outermost root node.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> slice =
exports.slice = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(start, end, root)</span> </span>{
    <span class="hljs-keyword">var</span> swap, extract;
    
    <span class="hljs-comment">// convert start and end to cursors</span>
    start = start == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : Cursor.toCursor(start);
    end = end == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : Cursor.toCursor(end);

    <span class="hljs-comment">// get the true root</span>
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (start == <span class="hljs-literal">null</span> || end == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Must specify a root node if start and end cursors are not defined."</span>);
        root = getRootNode(start == <span class="hljs-literal">null</span> ? end.node : start.node);
    }

    <span class="hljs-comment">// resolve the start and end if they are null</span>
    <span class="hljs-keyword">if</span> (!start) start = <span class="hljs-keyword">new</span> Cursor(root, <span class="hljs-literal">false</span>);
    <span class="hljs-keyword">if</span> (!end) end = <span class="hljs-keyword">new</span> Cursor(root, <span class="hljs-literal">true</span>);

    <span class="hljs-comment">// make sure the start and end are in bounds</span>
    <span class="hljs-keyword">if</span> (!contains(root, start.node)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Start node isn't in the root node."</span>);
    <span class="hljs-keyword">if</span> (!contains(root, end.node)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"End node isn't in the root node."</span>);

    <span class="hljs-comment">// swap the start and end if they are in the wrong order</span>
    <span class="hljs-keyword">if</span> (start.isAfter(end)) {
        swap = start;
        start = end;
        end = swap;
    }
    
    <span class="hljs-keyword">return</span> (extract = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node)</span> </span>{
        <span class="hljs-comment">// check if this node wraps or is inside of the start and end nodes</span>
        <span class="hljs-keyword">if</span> (contains(node, start.node) || contains(node, end.node) || (start.isBefore(node) &amp;&amp; end.isAfter(node))) {
            <span class="hljs-keyword">var</span> clone = node.cloneNode(<span class="hljs-literal">false</span>);
            
            <span class="hljs-comment">// make sure to chop end text nodes properly</span>
            <span class="hljs-keyword">if</span> (node.nodeType === Node.TEXT_NODE) {
                <span class="hljs-keyword">var</span> text = node.nodeValue,
                    isStart = matches(node, start.node),
                    isEnd = matches(node, end.node);
                
                <span class="hljs-keyword">if</span> (isStart &amp;&amp; isEnd) {
                    text = text.substring(start.index, end.index);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isStart) {
                    text = text.substr(start.index);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isEnd) {
                    text = text.substr(<span class="hljs-number">0</span>, end.index);
                }
                
                clone.nodeValue = text;
            }
            
            <span class="hljs-comment">// recursively clone children</span>
            <span class="hljs-keyword">if</span> (node.hasChildNodes()) {
                <span class="hljs-built_in">Array</span>.prototype.slice.call(node.childNodes, <span class="hljs-number">0</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(child)</span> </span>{
                    <span class="hljs-keyword">var</span> nc = extract(child);
                    <span class="hljs-keyword">if</span> (nc != <span class="hljs-literal">null</span>) clone.appendChild(nc);
                });
            }
            
            <span class="hljs-keyword">return</span> clone;
        }
    })(root);
}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
